<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Blog创建</title>
    <url>/Q./2022/02/03/Blog%E5%88%9B%E5%BB%BA-NextTheme/</url>
    <content><![CDATA[<p>这篇文章主要介绍个人Blog的创建</p>
<span id="more"></span>
<h1 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h1><p>Node.js<br>Git<br>Sublime Text<br>链接：<a href="https://pan.baidu.com/s/1HXpwYLKjNqWcWEGheD6-ug?pwd=d4jm">https://pan.baidu.com/s/1HXpwYLKjNqWcWEGheD6-ug?pwd=d4jm </a><br>提取码：d4jm<br>也可以到软件官网下载</p>
<h1 id="搭建Hexo"><a href="#搭建Hexo" class="headerlink" title="搭建Hexo"></a>搭建Hexo</h1><p>新建一个文件夹作为Blog的根目录<br>在目录下空白区域右击，打开Git Bash Here<br>输入以下代码</p>
<h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<h2 id="Hexo初始化配置"><a href="#Hexo初始化配置" class="headerlink" title="Hexo初始化配置"></a>Hexo初始化配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<h2 id="查看本地运行效果"><a href="#查看本地运行效果" class="headerlink" title="查看本地运行效果"></a>查看本地运行效果</h2><p>更改博客时也可以通过本地查看<br>hexo generate用于生成Hexo页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>也可以简写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>接着：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>hexo server用于本地运行Blog，也可以简写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>出现以下信息说明本地运行成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>可以打开网址 <a href="http://0.0.0.0:4000/">http://0.0.0.0:4000/</a> 查看效果<br>Ctrl+C 关闭本地运行</p>
<h1 id="创建GitHub账号并配置仓库"><a href="#创建GitHub账号并配置仓库" class="headerlink" title="创建GitHub账号并配置仓库"></a>创建GitHub账号并配置仓库</h1><h2 id="创建Github账号"><a href="#创建Github账号" class="headerlink" title="创建Github账号"></a>创建Github账号</h2><p><a href="https://github.com/">Github官网</a></p>
<h2 id="创建一个Blog仓库"><a href="#创建一个Blog仓库" class="headerlink" title="创建一个Blog仓库"></a>创建一个Blog仓库</h2><p>点击头像&gt;Your repositories&gt;New创建一个仓库<br><img src="https://s3.bmp.ovh/imgs/2022/02/c612b761898488bd.jpg"></p>
<h2 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h2><p>1.在Blog根目录下Git Bash，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/499f527e6edeb513.png"><br>2.继续输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your email@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>引号里填写你的邮箱地址，写注册Github时的邮箱<br>3.按回车键直到没有输出<br>4.获取公钥<br>输入以下命令将公钥复制到系统剪切板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<h2 id="在Github添加公钥"><a href="#在Github添加公钥" class="headerlink" title="在Github添加公钥"></a>在Github添加公钥</h2><p>点击头像&gt;Settings&gt;SSH and GPG keys&gt;New SSH key&gt;添加SSH keys<br><img src="https://s2.loli.net/2022/02/03/z5rSIUOi8dgkRTC.jpg"><br>测试ssh是否绑定成功，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>出现如下信息则成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi &quot;Your Name&quot;! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>引号内是你的Github昵称</p>
<h2 id="配置Git个人信息"><a href="#配置Git个人信息" class="headerlink" title="配置Git个人信息"></a>配置Git个人信息</h2><p>在Blog根目录下Git Bash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;此处填你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;此处填你的邮箱&quot;</span><br></pre></td></tr></table></figure>

<h1 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h1><h2 id="实现本地和远程仓库的连接"><a href="#实现本地和远程仓库的连接" class="headerlink" title="实现本地和远程仓库的连接"></a>实现本地和远程仓库的连接</h2><p>1.打开仓库复制仓库地址<br><img src="https://s2.loli.net/2022/02/03/b518QOfrnv67EC4.jpg"><br>2.打开Blog根目录下的_config.yml 文件<br>修改最底部的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure>
<p>为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/xxx/xxx.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<p>3.安装hexo-deployer-git自动部署发布工具<br>在Blog根目录下Git Bash，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>4.将本地Blog上传至远程仓库<br>接着输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>出现以下情况不慌，GitHub是外国的网，网络连接可能不稳定，重新hexo d直到上传成功<br>有些本地上传需要令牌(会弹出一个羽毛笔图标的输入框)，下面介绍如何用令牌代替密码<br><img src="https://s3.bmp.ovh/imgs/2022/02/02b5fbe9b8cab920.png"></p>
<h2 id="用令牌代替密码"><a href="#用令牌代替密码" class="headerlink" title="用令牌代替密码"></a>用令牌代替密码</h2><p>1.点击头像&gt;Setting&gt;Developer settings&gt;Personal access tokens&gt;Generate new token<br><img src="https://s2.loli.net/2022/02/03/uDx2MmvQXnAj6JI.png" alt="10.png"><br>2.生成令牌<br><img src="https://s2.loli.net/2022/02/03/XDrivmuhlKJWyt2.png" alt="11.png"><br>令牌生成后复制到文本文档中，因为第二次进入后令牌会被隐藏<br>这样就可以用令牌代替密码将本地文件上传到远程仓库了</p>
<h1 id="访问Blog"><a href="#访问Blog" class="headerlink" title="访问Blog"></a>访问Blog</h1><p>点击头像&gt;Your repositories&gt;打开仓库&gt;Setting<br>往下翻找到：<br><img src="https://s3.bmp.ovh/imgs/2022/02/a770c9a53cc78d0e.png"><br>新建的Blog需要设置Branch<br><img src="https://s3.bmp.ovh/imgs/2022/02/6909c946cbbd9e90.png"><br>等待一会儿后你的Blog就算成功的完成啦<br><img src="https://s3.bmp.ovh/imgs/2022/02/6607a6a9c50007ca.png"></p>
<h1 id="Blog的个性化"><a href="#Blog的个性化" class="headerlink" title="Blog的个性化"></a>Blog的个性化</h1><p>Blog可以通过部署Hexo主题以及配置组件达到个性化效果<br>具体请见Blog标签&#x2F;分类中的<em>Blog个性化</em></p>
]]></content>
      <categories>
        <category>Blog创建</category>
      </categories>
      <tags>
        <tag>Blog创建</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity游戏开发日志</title>
    <url>/Q./2022/02/03/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="2022-2-2"><a href="#2022-2-2" class="headerlink" title="2022.2.2"></a>2022.2.2</h1><p>1.完成Unity在VS中的环境配置<br>2.完成C#Script的创建<br>3.实现tilemap障碍物刚体<br>4.实现角色碰撞体和物理配置<br>5.实现角色Idle和run动画机的创建<br>6.实现角色Idle和run时方向的变换<br>7.解决角色方向变换不协调的问题</p>
<h1 id="2022-2-4"><a href="#2022-2-4" class="headerlink" title="2022.2.4"></a>2022.2.4</h1><p>1.完成Idle的Bool参数设定，Attack的Trigger参数设定<br>2.实现角色单次攻击</p>
<h1 id="2022-2-6"><a href="#2022-2-6" class="headerlink" title="2022.2.6"></a>2022.2.6</h1><p>1.完成Attack的Int参数设定，Attack的Bool参数设定<br>2.引入连击计数器HitCount<br>3.实现人物多段攻击<br>4.实现攻击结束函数<br>5.实现攻击结束函数在攻击动画尾帧的插入</p>
]]></content>
      <categories>
        <category>Unity游戏开发</category>
      </categories>
      <tags>
        <tag>Unity日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity游戏开发笔记</title>
    <url>/Q./2022/02/06/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>中国剩余定理</title>
    <url>/Q./2022/02/04/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>这篇文章主要介绍<strong>中国剩余定理及其解法</strong>以及<strong>代码实现</strong></p>
<span id="more"></span>
<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><h2 id="引子：曹冲养猪"><a href="#引子：曹冲养猪" class="headerlink" title="引子：曹冲养猪"></a>引子：曹冲养猪</h2><p>题目链接：<a href="https://www.luogu.com.cn/problem/P1495">https://www.luogu.com.cn/problem/P1495</a><br>自从曹冲搞定了大象以后，曹操就开始捉摸让儿子干些事业，于是派他到中原养猪场养猪，可是曹冲满不高兴，于是在工作中马马虎虎，有一次曹操想知道母猪的数量，于是曹冲想狠狠耍曹操一把。举个例子，假如有 1616 头母猪，如果建了 33 个猪圈，剩下 11 头猪就没有地方安家了。如果建造了 55 个猪圈，但是仍然有 11 头猪没有地方去，然后如果建造了 77 个猪圈，还有 22 头没有地方去。你作为曹总的私人秘书理所当然要将准确的猪数报给曹总，你该怎么办？</p>
<p>类似此类问题我们可以使用<strong>中国剩余定理</strong>求解<br>限制条件<strong>模两两互质</strong></p>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>推导过程来源于<a href="https://baike.baidu.com/item/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86/2841597?fromtitle=%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86&fromid=11200132&fr=aladdin"><strong>百度百科</strong></a>(主要是<em>太菜了</em>不会推导)<br><img src="https://s3.bmp.ovh/imgs/2022/02/55836b4e60ab409a.png"><br><img src="https://s3.bmp.ovh/imgs/2022/02/fee95cb9985307ad.png"></p>
<h2 id="求解模板"><a href="#求解模板" class="headerlink" title="求解模板"></a>求解模板</h2><p>以如下问题为例<br>问：有数模3余2，模5余3，模7余2，问数几何？</p>
<ul>
<li><strong>衍数</strong>：lcm&#x2F;除数</li>
<li><strong>逆元</strong>：为衍数模除数意义下的数论倒数，设衍数为a,除数为b，则逆元为ax ≡ 1(mod b)的最小正整数解</li>
<li><strong>各总</strong>：余数 * 衍数 * 逆元</li>
</ul>
<table>
<thead>
<tr>
<th><strong>除数</strong></th>
<th><strong>余数</strong></th>
<th><strong>除数最小公倍数(lcm)</strong></th>
<th><strong>衍数</strong></th>
<th><strong>逆元</strong></th>
<th><strong>各总</strong></th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>2</td>
<td>105</td>
<td>35</td>
<td>2</td>
<td>140</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>105</td>
<td>21</td>
<td>1</td>
<td>63</td>
</tr>
<tr>
<td>7</td>
<td>2</td>
<td>105</td>
<td>15</td>
<td>1</td>
<td>30</td>
</tr>
</tbody></table>
<p>将”各总”相加得到特解233<br>最后将233对lcm取模得到最小正整数解23<br>23即为所求</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;</span><br><span class="line">	if(b==0)&#123;</span><br><span class="line">		x=1,y=0;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	exgcd(b,a%b,y,x);</span><br><span class="line">	y-=(a/b)*x;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">	x=0,y=0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	n=read();</span><br><span class="line">	for(int i=1;i&lt;=n;i++) m[i]=read(),ai[i]=read();</span><br><span class="line">	ll M=1;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) M*=(ll)m[i];//求lcm </span><br><span class="line">	for(int i=1;i&lt;=n;i++) mi[i]=M/m[i];//求衍数 </span><br><span class="line">	//求逆元</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;exgcd(mi[i],m[i],x,y);ti[i]=(x%m[i]+m[i])%m[i];init();&#125;</span><br><span class="line">	ll minx=0;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) minx+=(mi[i]*ai[i]*ti[i])%M;</span><br><span class="line">	printf(&quot;%lld&quot;,minx%M);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>同余&amp;逆元&amp;不定方程</title>
    <url>/Q./2022/02/04/%E5%90%8C%E4%BD%99/</url>
    <content><![CDATA[<p>这篇文章主要介绍<strong>同余</strong>&amp;<strong>逆元</strong>&amp;<strong>不定方程</strong>及<strong>代码实现</strong></p>
<span id="more"></span>
<p>由于本人比较<em>菜</em>，所以一些定理不予证明</p>
<h1 id="同余的概念"><a href="#同余的概念" class="headerlink" title="同余的概念"></a>同余的概念</h1><p>同余定理是数论中的重要概念。给定一个正整数m，如果两个整数a和b满足（a-b）能够被m整除，即（a-b）&#x2F;m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)<br>【定义】设m是大于1的正整数，a、b是整数，如果m|(a-b)，则称a与b关于模m同余，记作a≡b(mod m)。显然易得如下：</p>
<p>1.若a≡0(mod m)，则m|a;<br>2.a≡b(mod m)等价于a与b分别用m去除，余数相同。<br><strong>充要性证明</strong><br>充分性：<br>若a和b用m相除留下相同的余数r，则 a&#x3D;q1m+r, b&#x3D;q2m+r,q1和q2为某两个整数，由此的a-b&#x3D;(q1m+r)-(q2m-r)&#x3D;m(q1-q2)，根据整除定义，我们有m|(a-b)，由同余式定义得出结论：a≡b(mod m)<br>必要性：<br>若a和b用m相除留下相同的余数r，则 a&#x3D;q1m+r,b&#x3D;q2m+r,所以a-b&#x3D;m(q1-q2) 故 m|(a-b)。<br><strong>同余性质</strong><br>反身性：a≡a (mod m)</p>
<p>对称性： 若a≡b(mod m)，则b≡a(mod m)</p>
<p>传递性： 若a≡b(mod m)，b≡c(mod m)，则a≡c(mod m)</p>
<p>同余式相加：若a≡b(mod m)，b≡c(mod m)，则a ± c≡b ± d(mod m)</p>
<p>同余式相乘：若a≡b(mod m)，b≡c(mod m)，则ac≡bd(mod m)</p>
<p>线性运算：如果a≡b(mod m)，c≡d(mod m)，那么a ± c≡b ± d(mod m)，且a * c≡b * d(mod m)</p>
<p>除法：若ac ≡ bc (mod m) c≠0 则 a≡ b (mod m&#x2F;gcd(c,m)) 其中gcd(c,m)表示c,m的最大公约数。特殊地 ,gcd(c,m)&#x3D;1 则a ≡ b (mod m)</p>
<p>幂运算：如果a ≡ b (mod m)，那么a^n ≡ b^n (mod m)</p>
<p>若a ≡ b (mod m)，n|m,则 a ≡ b (mod n)</p>
<p>若a ≡ b (mod mi) (i&#x3D;1,2…n) 则 a ≡ b (mod [m1,m2,…mn]) 其中[m1,m2,…mn]表示m1,m2,…mn的最小公倍数</p>
<h1 id="逆元-amp-不定方程"><a href="#逆元-amp-不定方程" class="headerlink" title="逆元&amp;不定方程"></a>逆元&amp;不定方程</h1><h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p>每个数a均有唯一的与之对应的乘法逆元x，使得ax≡1(mod b) ， 一个数有逆元的<strong>充分必要条件是gcd(a,b)&#x3D;1</strong>，此时逆元唯一存在 。<br>【含义】模b意义下，1个数a如果有逆元x，那么除以a相当于乘以x。<br>【定义】正整数 a, b，如果有 ax ≡ 1(mod b)，则称 x 的最小正整数解为 a 模 b的<strong>逆元</strong></p>
<h2 id="不定方程"><a href="#不定方程" class="headerlink" title="不定方程"></a>不定方程</h2><p>【定义】形如ax+by&#x3D;c（a，b，c均为常数，且a，b均不为0），一般情况下，每一个x的值都有一个y值和它相对应，有无穷多组解。如果方程（组）中，解的数值不能唯一确定，这样的方程（组）称为不定方程<br><strong>不定方程有整数解的条件</strong><br>整系数二元不定方程ax+by&#x3D;c中的系数a，b的最大公约数能整除c。<br>反之，如果<strong>if(c%gcd(a,b))</strong> 则 <strong>无解</strong></p>
<h2 id="逆元-amp-不定方程解法"><a href="#逆元-amp-不定方程解法" class="headerlink" title="逆元&amp;不定方程解法"></a>逆元&amp;不定方程解法</h2><h3 id="扩展欧几里得算法求不定方程"><a href="#扩展欧几里得算法求不定方程" class="headerlink" title="扩展欧几里得算法求不定方程"></a>扩展欧几里得算法求不定方程</h3><p>引：裴蜀定理<br>~ 设a, b是<strong>不全为零</strong>的整数，则存在整数x, y 使得 ax + by &#x3D; gcd(a, b)</p>
<p>我们都知道，欧几里得公式可以由这个式子表达<br><strong>gcd(a, b) &#x3D; gcd(b, a % b)</strong><br>通过这个式子，我们可以不断递推到b &#x3D; 0， 此时a即为a和b的<strong>最大公约数</strong><br>将式子展开得到如下<br><strong>1.gcd(a, b) &#x3D; a * x1 + b * x1</strong><br><strong>2.gcd(b, a % b) &#x3D; b * x2 + (a % b) * y2</strong><br>由欧几里得公式可得到<br><strong>a * x1+b * x1&#x3D;b * x2 + (a % b) * y2</strong><br>其中 <strong>a % b &#x3D; a - (a &#x2F; b) * b</strong><br>得 <strong>a * x1 + b * y1 &#x3D; b * x2 + [a - (a &#x2F; b) * b]y2</strong><br>化简得 <strong>a * x1 + b * y1 &#x3D; a * y2 + b * [x2 - (a &#x2F; b) * y2]</strong><br>由<strong>待定系数法</strong>得：<br><strong>1.x1 &#x3D; y2</strong><br><strong>2.y1 &#x3D; x2 - (a &#x2F; b) * y2</strong><br><em>以上即扩展欧几里得算法</em><br>也就是说有了<strong>gcd(b, a % b)的解x2, y2</strong>就可以推出<strong>gcd(a, b)的解x1, y1</strong><br>我们可以用类似求gcd的方法求解，一直推到x&#x3D;1,y&#x3D;0(递归边界)，然后回溯即可求出特解</p>
<h3 id="通过特解求出最小整数解-amp-通解"><a href="#通过特解求出最小整数解-amp-通解" class="headerlink" title="通过特解求出最小整数解&amp;通解"></a>通过特解求出最小整数解&amp;通解</h3><p>设特解分别为x0,y0<br>则最小解为：<br><strong>x0&#x3D;x0%(b&#x2F;gcd(a,b))</strong><br>则通解为：<br><strong>x&#x3D;x0+k*b&#x2F;gcd(a,b)</strong><br><strong>y&#x3D;y0-k*a&#x2F;gcd(a,b)</strong><br>又因为方程建立在gcd基础上，方程左边为gcd而非c，所以答案需在上面的基础上乘上<br><strong>c&#x2F;gcd(a,b)</strong><br>所以最小解为<br><strong>x0&#x3D;(x0*c&#x2F;gcd(a,b))%(b&#x2F;gcd)</strong></p>
<p>易知<strong>逆元为特殊的不定方程</strong>，ax≡1(mod b) 等价于ax-by&#x3D;1<br>所以同样可以用<strong>扩展欧几里得算法求解</strong></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>扩展欧几里得算法的三大应用</p>
<h2 id="求不定方程ax-by-x3D-c的最小正整数解"><a href="#求不定方程ax-by-x3D-c的最小正整数解" class="headerlink" title="求不定方程ax+by&#x3D;c的最小正整数解"></a>求不定方程ax+by&#x3D;c的最小正整数解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void exgcd(int a,int b,int &amp;x,int &amp;y)&#123;</span><br><span class="line">	if(b==0)&#123;</span><br><span class="line">		x=1,y=0;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	exgcd(b,a%b,y,x);</span><br><span class="line">	y-=(a/b)*x;</span><br><span class="line">&#125;//x即为特解;</span><br><span class="line">int mod=b/(gcd(a,b));</span><br><span class="line">ans=(x*(c/gcd(a,b))%mod+mod)%mod;</span><br><span class="line">//小技巧，+mod后%mod可以防止出现负解;</span><br></pre></td></tr></table></figure>
<h2 id="求方程ax≡1-mod-b-的最小正整数解-a的逆元"><a href="#求方程ax≡1-mod-b-的最小正整数解-a的逆元" class="headerlink" title="求方程ax≡1(mod b) 的最小正整数解(a的逆元)"></a>求方程ax≡1(mod b) 的最小正整数解(a的逆元)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void exgcd(int a,int b,int &amp;x,int &amp;y)&#123;</span><br><span class="line">	if(b==0)&#123;</span><br><span class="line">		x=1,y=0;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	exgcd(b,a%b,y,x);</span><br><span class="line">	y-=(a/b)*x;</span><br><span class="line">&#125;//x即为特解;</span><br><span class="line">//已知gcd(a,b)=1,则mod=b/gcd(a,b)=b;</span><br><span class="line">//同理，c/gcd(a,b)=1/1=1;</span><br><span class="line">ans=(x%b+b)%b//求出最小整数解&amp;防止出现负解;</span><br></pre></td></tr></table></figure>

<h2 id="求模线性方程ax≡b-mod-n"><a href="#求模线性方程ax≡b-mod-n" class="headerlink" title="求模线性方程ax≡b (mod n)"></a>求模线性方程ax≡b (mod n)</h2><p>对于模线性方程ax≡b (mod n)可以化简为ax+ny&#x3D;b设d&#x3D;gcd(a,n)<br>则当且仅当b%d&#x3D;&#x3D;0时方程有解，且有d个解<br>等式两边同时乘以b&#x2F;d，则方程变为axb&#x2F;d+nyb&#x2F;d&#x3D;b<br>设ax+ny&#x3D;d特解为x‘,y’<br>则原方程解为x&#x3D;x‘ * b&#x2F;d，y&#x3D;y’ * b&#x2F;d<br>故ax≡b (mod n)特解为<strong>x0&#x3D;x’ * (b&#x2F;d)%n</strong><br>d个解为xi&#x3D;x0+i*(n&#x2F;d)%n (i&#x3D;0,1,…,n-1)<br>解的间隔为<strong>n&#x2F;d</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void exgcd(int a,int b,int &amp;gcd,int &amp;x,int &amp;y)&#123;</span><br><span class="line">	if(b==0)&#123;</span><br><span class="line">		x=1,y=0;</span><br><span class="line">		gcd=a;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	exgcd(b,a%b,y,x);</span><br><span class="line">	y-=(a/b)*x;</span><br><span class="line">&#125;</span><br><span class="line">bool check_find(int a,int b,int n)&#123;</span><br><span class="line">	int x,y,x0,gcd;</span><br><span class="line">	exgcd(a,b,gcd,x,y);</span><br><span class="line">	int d=gcd;</span><br><span class="line">	if(b%d) return false;</span><br><span class="line">	x0=x*(b/d)%n;//特解</span><br><span class="line">	for(int i=0,i&lt;d;i++) printf(&quot;%d\n&quot;,x0+i*(n/d));</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
