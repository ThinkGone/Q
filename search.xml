<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于Github的Blog搭建</title>
    <url>/2022/02/03/Blog%E5%88%9B%E5%BB%BA-NextTheme/</url>
    <content><![CDATA[<p>这篇文章主要介绍个人Blog的搭建</p>
<span id="more"></span>
<h1 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h1><p>Node.js<br>Git<br>Sublime Text<br>链接：<a href="https://pan.baidu.com/s/1HXpwYLKjNqWcWEGheD6-ug?pwd=d4jm">https://pan.baidu.com/s/1HXpwYLKjNqWcWEGheD6-ug?pwd=d4jm </a><br>提取码：d4jm<br>也可以到软件官网下载</p>
<h1 id="搭建Hexo"><a href="#搭建Hexo" class="headerlink" title="搭建Hexo"></a>搭建Hexo</h1><p>新建一个文件夹作为Blog的根目录<br>在目录下空白区域右击，打开Git Bash Here<br>输入以下代码</p>
<h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<h2 id="Hexo初始化配置"><a href="#Hexo初始化配置" class="headerlink" title="Hexo初始化配置"></a>Hexo初始化配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<h2 id="查看本地运行效果"><a href="#查看本地运行效果" class="headerlink" title="查看本地运行效果"></a>查看本地运行效果</h2><p>更改博客时也可以通过本地查看<br>hexo generate用于生成Hexo页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>也可以简写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>接着：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>hexo server用于本地运行Blog，也可以简写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>出现以下信息说明本地运行成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>可以打开网址 <a href="http://0.0.0.0:4000/">http://0.0.0.0:4000/</a> 查看效果<br>Ctrl+C 关闭本地运行</p>
<h1 id="创建GitHub账号并配置仓库"><a href="#创建GitHub账号并配置仓库" class="headerlink" title="创建GitHub账号并配置仓库"></a>创建GitHub账号并配置仓库</h1><h2 id="创建Github账号"><a href="#创建Github账号" class="headerlink" title="创建Github账号"></a>创建Github账号</h2><p><a href="https://github.com/">Github官网</a></p>
<h2 id="创建一个Blog仓库"><a href="#创建一个Blog仓库" class="headerlink" title="创建一个Blog仓库"></a>创建一个Blog仓库</h2><p>点击头像&gt;Your repositories&gt;New创建一个仓库<br><img src="https://s3.bmp.ovh/imgs/2022/02/c612b761898488bd.jpg"></p>
<h2 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h2><p>1.在Blog根目录下Git Bash，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/499f527e6edeb513.png"><br>2.继续输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your email@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>引号里填写你的邮箱地址，写注册Github时的邮箱<br>3.按回车键直到没有输出<br>4.获取公钥<br>输入以下命令将公钥复制到系统剪切板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<h2 id="在Github添加公钥"><a href="#在Github添加公钥" class="headerlink" title="在Github添加公钥"></a>在Github添加公钥</h2><p>点击头像&gt;Settings&gt;SSH and GPG keys&gt;New SSH key&gt;添加SSH keys<br><img src="https://s2.loli.net/2022/02/03/z5rSIUOi8dgkRTC.jpg"><br>测试ssh是否绑定成功，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>出现如下信息则成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi &quot;Your Name&quot;! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>引号内是你的Github昵称</p>
<h2 id="配置Git个人信息"><a href="#配置Git个人信息" class="headerlink" title="配置Git个人信息"></a>配置Git个人信息</h2><p>在Blog根目录下Git Bash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;此处填你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;此处填你的邮箱&quot;</span><br></pre></td></tr></table></figure>

<h1 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h1><h2 id="实现本地和远程仓库的连接"><a href="#实现本地和远程仓库的连接" class="headerlink" title="实现本地和远程仓库的连接"></a>实现本地和远程仓库的连接</h2><p>1.打开仓库复制仓库地址<br><img src="https://s2.loli.net/2022/02/03/b518QOfrnv67EC4.jpg"><br>2.打开Blog根目录下的_config.yml 文件<br>修改最底部的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure>
<p>为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/xxx/xxx.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<p>3.安装hexo-deployer-git自动部署发布工具<br>在Blog根目录下Git Bash，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>4.将本地Blog上传至远程仓库<br>接着输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>出现以下情况不慌，GitHub是外国的网，网络连接可能不稳定，重新hexo d直到上传成功<br>有些本地上传需要令牌(会弹出一个羽毛笔图标的输入框)，下面介绍如何用令牌代替密码<br><img src="https://s3.bmp.ovh/imgs/2022/02/02b5fbe9b8cab920.png"></p>
<h2 id="用令牌代替密码"><a href="#用令牌代替密码" class="headerlink" title="用令牌代替密码"></a>用令牌代替密码</h2><p>1.点击头像&gt;Setting&gt;Developer settings&gt;Personal access tokens&gt;Generate new token<br><img src="https://s2.loli.net/2022/02/03/uDx2MmvQXnAj6JI.png" alt="10.png"><br>2.生成令牌<br><img src="https://s2.loli.net/2022/02/03/XDrivmuhlKJWyt2.png" alt="11.png"><br>令牌生成后复制到文本文档中，因为第二次进入后令牌会被隐藏<br>这样就可以用令牌代替密码将本地文件上传到远程仓库了</p>
<h1 id="访问Blog"><a href="#访问Blog" class="headerlink" title="访问Blog"></a>访问Blog</h1><p>点击头像&gt;Your repositories&gt;打开仓库&gt;Setting<br>往下翻找到：<br><img src="https://s3.bmp.ovh/imgs/2022/02/a770c9a53cc78d0e.png"><br>新建的Blog需要设置Branch<br><img src="https://s3.bmp.ovh/imgs/2022/02/6909c946cbbd9e90.png"><br>等待一会儿后你的Blog就算成功的完成啦<br><img src="https://s3.bmp.ovh/imgs/2022/02/6607a6a9c50007ca.png"></p>
<h1 id="Blog的个性化"><a href="#Blog的个性化" class="headerlink" title="Blog的个性化"></a>Blog的个性化</h1><p>Blog可以通过部署Hexo主题以及配置组件达到个性化效果<br>具体请见Blog标签&#x2F;分类中的<em>Blog个性化</em></p>
]]></content>
      <categories>
        <category>Blog搭建</category>
      </categories>
      <tags>
        <tag>Blog搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Butterfly主题美化进阶</title>
    <url>/2022/04/21/Butterfly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="页脚养鱼"><a href="#页脚养鱼" class="headerlink" title="页脚养鱼"></a>页脚养鱼</h2><p>首先到这两个网址引入必要的 js 文件  </p>
<ul>
<li><a href="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js">https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js</a></li>
<li><a href="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;xiabo2&#x2F;CDN@latest&#x2F;fishes.js</a></li>
</ul>
<p>复制下来保存在TXT文件中分别命名为为 <strong>jquery.min</strong> 和 <strong>fishes</strong><br>然后 <strong>修改后缀为 js</strong><br>放在博客根目录的 <strong>themes&#x2F;butterfly&#x2F;source&#x2F;js&#x2F;</strong> 文件夹中</p>
<p>修改 <strong>主体配置文件</strong> _config.yml ，Ctrl + F 查找 <strong>inject</strong><br>写下以下代码：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/fishes.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就可以在页脚养鱼啦</p>
]]></content>
      <categories>
        <category>主题美化</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Github的Blog绑定阿里云域名</title>
    <url>/2022/02/04/GitHub%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>这篇文章主要介绍基于Github的Blog绑定阿里云域名</p>
<span id="more"></span>
<h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>进入阿里云查找自己所需的域名并购买<br><a href="https://www.aliyun.com/">https://www.aliyun.com/</a></p>
<h3 id="获取Blog的记录值"><a href="#获取Blog的记录值" class="headerlink" title="获取Blog的记录值"></a>获取Blog的记录值</h3><p><strong>win+R输入cmd</strong> 打开管理员命令行界面<br>使用 <strong>ping</strong> 命令获取Blog的 <strong>记录值</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ping yourgithubname.github.io</span><br><span class="line"><span class="comment">//yourgithubname为你GitHub的用户名</span></span><br></pre></td></tr></table></figure>
<p>获得如下图所示结果：<br><img src="https://s3.bmp.ovh/imgs/2022/04/04/35ded9b7985ad130.png"><br>获取的红框内容即为 <strong>记录值</strong></p>
<h3 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h3><p>将获得的记录值解析到购买的域名<br>直接使用 <strong>“新手指导”</strong> 填入记录值保存即可<br><img src="https://s3.bmp.ovh/imgs/2022/04/04/b61a86bb2f91edcb.png"></p>
<h3 id="GitHub配置CNAME"><a href="#GitHub配置CNAME" class="headerlink" title="GitHub配置CNAME"></a>GitHub配置CNAME</h3><p>在GitHub对应Blog仓库的&lt;&gt;Code中<br>创建CNAME文件<br>仅需要添加一行你的域名地址即可<br>比如我的就是 <a href="q-thinkgone.cn">q-thinkgone.cn</a><br><img src="https://s3.bmp.ovh/imgs/2022/04/04/959015c1d3ca675f.png">  </p>
<h3 id="修改Blog根目录下的-config-yml文件"><a href="#修改Blog根目录下的-config-yml文件" class="headerlink" title="修改Blog根目录下的_config.yml文件"></a>修改Blog根目录下的_config.yml文件</h3><p>将对应的 <strong>URL</strong> 地址修改为绑定的域名<br><img src="https://s3.bmp.ovh/imgs/2022/04/04/6bc951497af6b29f.png"></p>
<h3 id="在GitHub添加所绑定域名"><a href="#在GitHub添加所绑定域名" class="headerlink" title="在GitHub添加所绑定域名"></a>在GitHub添加所绑定域名</h3><p>点击头像&gt;Settings<br>往下翻找到 <strong>GitHub Pages</strong><br>点击 <strong>Check it out here！</strong><br><img src="https://s3.bmp.ovh/imgs/2022/04/04/5390b68dbe2b242f.png"><br>在Custom domain中添加绑定的域名，save即可<br><img src="https://s3.bmp.ovh/imgs/2022/04/04/02f89999f81285ff.png">  </p>
<p>最后就可以在绑定的域名上访问你的Blog啦</p>
]]></content>
      <categories>
        <category>Blog搭建</category>
      </categories>
      <tags>
        <tag>Blog搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>P1763埃及分数-题解</title>
    <url>/2022/03/05/P1763%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>这篇文章为洛谷P1763埃及分数的题解</p>
<span id="more"></span>
<h2 id="本题解主要介绍朴素-IDA-的解法-360ms"><a href="#本题解主要介绍朴素-IDA-的解法-360ms" class="headerlink" title="本题解主要介绍朴素 IDA* 的解法( 360ms )"></a>本题解主要介绍朴素 IDA* 的解法( 360ms )</h2><h3 id="首先我们需要明白啥玩意是-IDA"><a href="#首先我们需要明白啥玩意是-IDA" class="headerlink" title="首先我们需要明白啥玩意是 IDA*"></a>首先我们需要明白啥玩意是 IDA*</h3><p>简单来说  IDA* &#x3D; <strong>迭代加深搜索</strong> + <strong>剪枝</strong><br>由于我们不清楚本题需要多少个分子为1的分数去拼凑这个答案<br>所以我们需要用到<strong>迭代加深搜索</strong><br>从1开始枚举深度，直到找到答案<br><img src="https://s3.bmp.ovh/imgs/2022/02/8fdb046c615aaf45.gif"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由题面我们不难看出分数是<strong>递减</strong>的<br><strong>下一级分数肯定比上一级分数小</strong><br>本蒟蒻采用从 a&#x2F;b 减去枚举的分数，直到达到深度作为边界的方法<br>枚举深度的同时枚举分母，且该分数刚刚好小于上一级所减去的剩下的 a&#x2F;b<br>(下文的 <strong>get_first</strong> 函数)<br>我们需要保证分子为 1<br>所以我们在边界的时候做处理:<br><strong>1 . 当经过上一级处理剩下的 a&#x2F;b 分子不为 1 ，return false</strong><br><strong>2 . 若为 1 ，则将该分母直接作为答案</strong><br>此时我们得到的解肯定是最优的<br>( 类比 bfs )</p>
<p>需要用到的函数有 ：<br>1 . gcd 函数 ( 便于约分 )<br>2 . better 函数 ( 更新答案 )<br>3 . get_firs t函数( 返回 ( 1 &#x2F; c ) &lt;&#x3D; ( num &#x2F; deo )的最小正整数 c )<br>4 . dfs 函数  </p>
<p>兼职学习英语 ：<br>Numerator 分子<br>Denominator 分母</p>
<p>朴素的迭代代码如下 ：<br>( 请原谅本蒟蒻害怕溢出时刻用 long long )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000005</span>;</span><br><span class="line">ll a,b;</span><br><span class="line">ll v[maxn],ans[maxn];</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">get_first</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;;i++) <span class="keyword">if</span>(<span class="built_in"><span class="keyword">double</span></span>(<span class="number">1.0</span>*<span class="number">1</span>/i)&lt;<span class="built_in"><span class="keyword">double</span></span>(<span class="number">1.0</span>*a/b)) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">better</span><span class="params">(ll dep)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v[dep]&lt;ans[dep]) <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=dep;i++) ans[i]=v[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(ll dep,ll c,ll num,ll deo,ll maxd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep==maxd)&#123;</span><br><span class="line">		<span class="keyword">if</span>(deo%num) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//若不满足埃及分数要求，退出</span></span><br><span class="line">		v[dep]=deo/num;将该分母直接作为答案</span><br><span class="line">		<span class="built_in">better</span>(dep);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> ok=<span class="literal">false</span>;</span><br><span class="line">	c=<span class="built_in">max</span>(c,<span class="built_in">get_first</span>(num,deo));</span><br><span class="line">	<span class="keyword">for</span>(ll i=c;;i++)&#123;</span><br><span class="line">		ll x=num*i-deo;<span class="comment">//减去枚举到的分数</span></span><br><span class="line">		ll y=deo*i;</span><br><span class="line">		ll d=<span class="built_in">gcd</span>(x,y);<span class="comment">//约分</span></span><br><span class="line">		v[dep]=i;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">dfs</span>(dep+<span class="number">1</span>,i+<span class="number">1</span>,x/d,y/d,maxd)) ok=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	ll tot;</span><br><span class="line">	ll c=<span class="built_in">get_first</span>(a,b);</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">127</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">	<span class="keyword">for</span>(ll maxd=<span class="number">1</span>;;maxd++) <span class="keyword">if</span>(<span class="built_in">dfs</span>(<span class="number">1</span>,c,a,b,maxd))&#123;tot=maxd;<span class="keyword">break</span>;&#125;</span><br><span class="line">    <span class="comment">//找到的话肯定是深度较浅的优</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>但是本题的数据可能不允许你用朴素的迭代写法<br>后果如下 ：<br><img src="https://s3.bmp.ovh/imgs/2022/02/bee67bfe617c21f5.png"></p>
<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>所以我们需要 <strong>剪枝</strong><br>剪枝语句十分简单<br>当我们枚举分母的时候，分数随着分母增大而减少<br>所以当我们枚举到前面这个分母 ，此时<strong>即使后面所有的数都是该分数</strong> ，减去仍然大于 0 , 那么继续dfs下去也没什么意义<br>所以只需要在枚举分母时添加上剪枝语句即可  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(ll i=c;;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(deo*(maxd-dep+<span class="number">1</span>)&lt;=num*i) <span class="keyword">break</span>;</span><br><span class="line">		ll x=num*i-deo;</span><br><span class="line">		ll y=deo*i;</span><br><span class="line">		ll d=<span class="built_in">gcd</span>(x,y);</span><br><span class="line">		v[dep]=i;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">dfs</span>(dep+<span class="number">1</span>,i+<span class="number">1</span>,x/d,y/d,maxd)) ok=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以 AC 啦 ~<br>希望这篇题解对你有所帮助和启发</p>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>IDA*搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>P2140小Z的电力管制-题解</title>
    <url>/2022/04/21/P2140%E5%B0%8FZ%E7%9A%84%E7%94%B5%E5%8A%9B%E7%AE%A1%E5%88%B6-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>似乎这道题和 <a href="https://www.luogu.com.cn/problem/P1436">P1436</a> 以及 <a href="https://www.luogu.com.cn/problem/P5752">P5752</a> 的棋盘分割有很多相似之处 。  <del>（三倍经验）</del><br>题目对于电力的要求似乎有些复杂 。<br>简化来说就是 <strong>取各方案各个区域分值之和最小值最大</strong> 。<br>特来此写一篇较为详细的题解 。  </p>
<h2 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h2><p>类似于分割棋盘，我们可以使用进行 <strong>递归</strong> 分割 。<br>二维取区块和可以使用 <strong>二维前缀和</strong><br>但是答案有两个，可以使用结构体存储并维护 。<br>用 $f$ 数组进行 <strong>记忆化处理</strong> 优化时间复杂度 。</p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><p>易知递归边界是不可再分，即已经缩小到一个点 。<br>电力消耗值为所有需要的电 $tot$ 减去当前断电区域断掉的电 $broke$ 。<br>所有电力剩余值为 <strong>供电总值 - 电力消耗值</strong> 。<br>定义：</p>
<ul>
<li>$ans$ 为方案总数 。</li>
<li>$least$ 为电力剩余值 。</li>
</ul>
<p>如果当前方案较多，则替换已有方案，更新电力剩余值 。<br>如果方案数相同，则比较电力剩余值，选出较大的 。</p>
<h2 id="3-Code"><a href="#3-Code" class="headerlink" title="3.Code"></a>3.Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">35</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> ans;</span><br><span class="line">	<span class="keyword">int</span> least;</span><br><span class="line">&#125;f[maxn][maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,u;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k=sum[x2][y2]+sum[x1<span class="number">-1</span>][y1<span class="number">-1</span>]-sum[x1<span class="number">-1</span>][y2]-sum[x2][y1<span class="number">-1</span>];<span class="comment">//求区块分值和 </span></span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> broke)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x1][y1][x2][y2].ans) <span class="keyword">return</span> f[x1][y1][x2][y2];</span><br><span class="line">	Node tmp;tmp.ans=<span class="number">1</span>;tmp.least=u-tot+broke;</span><br><span class="line">	<span class="keyword">if</span>(x1==x2&amp;&amp;y1==y2) <span class="keyword">return</span> tmp;<span class="comment">//递归边界 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x1;i&lt;x2;i++)&#123;<span class="comment">//纵向分割 </span></span><br><span class="line">		<span class="keyword">int</span> area1=<span class="built_in">get_sum</span>(x1,y1,i,y2),area2=<span class="built_in">get_sum</span>(i+<span class="number">1</span>,y1,x2,y2);</span><br><span class="line">		<span class="keyword">if</span>(area1&lt;=u&amp;&amp;tot-area1&lt;=u&amp;&amp;area2&lt;=u&amp;&amp;tot-area2&lt;=u)&#123;</span><br><span class="line">			Node ans1=<span class="built_in">dfs</span>(x1,y1,i,y2,area1),ans2=<span class="built_in">dfs</span>(i+<span class="number">1</span>,y1,x2,y2,area2);</span><br><span class="line">			<span class="keyword">if</span>(ans1.ans+ans2.ans&gt;tmp.ans)&#123;<span class="comment">//替换已有方案，更新电力剩余值 </span></span><br><span class="line">				tmp.ans=ans1.ans+ans2.ans;</span><br><span class="line">				tmp.least=<span class="built_in">min</span>(ans1.least,ans2.least);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//比较电力剩余值，选出较大的</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(ans1.ans+ans2.ans==tmp.ans) tmp.least=<span class="built_in">max</span>(tmp.least,<span class="built_in">min</span>(ans1.least,ans2.least));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=y1;i&lt;y2;i++)&#123;<span class="comment">//横向分割 </span></span><br><span class="line">		<span class="keyword">int</span> area1=<span class="built_in">get_sum</span>(x1,y1,x2,i),area2=<span class="built_in">get_sum</span>(x1,i+<span class="number">1</span>,x2,y2);</span><br><span class="line">		<span class="keyword">if</span>(area1&lt;=u&amp;&amp;tot-area1&lt;=u&amp;&amp;area2&lt;=u&amp;&amp;tot-area2&lt;=u)&#123;</span><br><span class="line">			Node ans1=<span class="built_in">dfs</span>(x1,y1,x2,i,area1),ans2=<span class="built_in">dfs</span>(x1,i+<span class="number">1</span>,x2,y2,area2);</span><br><span class="line">			<span class="keyword">if</span>(ans1.ans+ans2.ans&gt;tmp.ans)&#123;</span><br><span class="line">				tmp.ans=ans1.ans+ans2.ans;</span><br><span class="line">				tmp.least=<span class="built_in">min</span>(ans1.least,ans2.least);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(ans1.ans+ans2.ans==tmp.ans) tmp.least=<span class="built_in">max</span>(tmp.least,<span class="built_in">min</span>(ans1.least,ans2.least));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[x1][y1][x2][y2]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]),tot+=a[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) sum[i][j]=a[i][j]+sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>];<span class="comment">//二维前缀和 </span></span><br><span class="line">	Node res=<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,n,m,tot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,res.ans,res.least);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>P5507机关-题解</title>
    <url>/2022/04/04/P5507%E6%9C%BA%E5%85%B3-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>这篇文章为洛谷P5507机关的题解</p>
<span id="more"></span>
<h3 id="这是道很好的搜索练手题"><a href="#这是道很好的搜索练手题" class="headerlink" title="这是道很好的搜索练手题"></a>这是道很好的搜索练手题</h3><p>可以用广为人知的搜索<del>三巨头</del>求解  </p>
<ul>
<li>双向搜索</li>
<li>IDA* （<del>在这题貌似被禁了</del>）</li>
<li>A*</li>
</ul>
<p>这篇题解主要介绍用 <strong>A_star</strong> 算法 AC 这道题  </p>
<h2 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h2><p>用 <strong>结构体</strong> 记录 <strong>路径</strong> <strong>状态</strong><br>以及实际步数 <strong>g(n)</strong> 和估价步数 <strong>h(n)</strong><br>我们都知道 A* 算法的核心在于其估价函数 <strong>h(n)</strong><br>每次取出对应 <strong>g(n) + h(n)</strong> <strong>最小的</strong> 进行下一步搜素  </p>
<p>引出一个疑惑 ：<br>每改变一个机关的状态都会有另一个机关跟着改变<br>那么估价函数如何求解 ？<br>看作是两个一起变换<br>可以 <strong>用当前状态距离目标状态的理想差值除去 2 得到</strong></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><p>使用优先队列存储结构体<br>所以我们需要 <strong>重载运算符</strong>  ： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.g+a.h&gt;b.g+b.h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经检验 ：<br>由于看作两个机关同时向着目标前进 <strong>过于理想</strong><br>此题的估价函数可以稍微调高一些，用于优化时间复杂度<br>参数为原估价函数的  <strong>1.3</strong> 倍<br>但此时的时间复杂度仍高了些<br>所以最后加上 <strong>map 去重</strong> 即可</p>
<h2 id="3-Code"><a href="#3-Code" class="headerlink" title="3. Code"></a>3. Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	string state;<span class="comment">//状态 </span></span><br><span class="line">	string path;<span class="comment">//路径 </span></span><br><span class="line">	<span class="keyword">int</span> g;<span class="comment">//实际步数 </span></span><br><span class="line">	<span class="keyword">int</span> h;<span class="comment">//估价函数 </span></span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string,<span class="keyword">bool</span>&gt; mark;</span><br><span class="line"><span class="comment">//重载运算符 </span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.g+a.h&gt;b.g+b.h;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="comment">//估价函数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eva</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=<span class="string">&#x27;1&#x27;</span>) cnt+=<span class="number">5</span>-(<span class="keyword">int</span>)(s[i]<span class="number">-48</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt/<span class="number">2</span>*<span class="number">1.3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s.g);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.path.<span class="built_in">size</span>();i++) cout&lt;&lt;(<span class="keyword">int</span>)(s.path[i]<span class="number">-48</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> gear[<span class="number">13</span>][<span class="number">5</span>];<span class="comment">//机关触发机制 </span></span><br><span class="line">	node start;</span><br><span class="line">	start.state+=(<span class="keyword">char</span>)(<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">			<span class="keyword">if</span>(j==<span class="number">1</span>) start.state+=(<span class="keyword">char</span>)(x+<span class="number">48</span>);</span><br><span class="line">			<span class="keyword">else</span> gear[i][j<span class="number">-1</span>]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	start.g=<span class="number">0</span>;</span><br><span class="line">	start.h=<span class="built_in">eva</span>(start.state);</span><br><span class="line">	<span class="keyword">if</span>(!start.h)&#123;<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	mark[start.state]=<span class="literal">true</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(start);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node a=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)&#123;</span><br><span class="line">			<span class="comment">//触发机关 </span></span><br><span class="line">			<span class="keyword">int</span> x=(<span class="keyword">int</span>)(a.state[i]<span class="number">-48</span>);<span class="comment">//x为i机关的状态 </span></span><br><span class="line">			<span class="keyword">int</span> j=gear[i][x];<span class="comment">//j为i机关的连锁机关 </span></span><br><span class="line">			<span class="keyword">int</span> y=(<span class="keyword">int</span>)(a.state[j]<span class="number">-48</span>);<span class="comment">//y为j机关的状态</span></span><br><span class="line">			<span class="comment">//改变状态 </span></span><br><span class="line">			<span class="keyword">if</span>(x==<span class="number">4</span>) x=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> x+=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(y==<span class="number">4</span>) y=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> y+=<span class="number">1</span>;</span><br><span class="line">			 </span><br><span class="line">			node s;<span class="comment">//转换入队列 </span></span><br><span class="line">			s.state+=(<span class="keyword">char</span>)(<span class="number">48</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=<span class="number">12</span>;u++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(u==i)&#123;s.state+=(<span class="keyword">char</span>)(x+<span class="number">48</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">				<span class="keyword">if</span>(u==j)&#123;s.state+=(<span class="keyword">char</span>)(y+<span class="number">48</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">				s.state+=a.state[u];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(!mark[s.state])&#123;<span class="comment">//map去重 </span></span><br><span class="line">				s.g=a.g+<span class="number">1</span>;</span><br><span class="line">				s.h=<span class="built_in">eva</span>(s.state);</span><br><span class="line">				mark[s.state]=<span class="literal">true</span>;</span><br><span class="line">				s.path=a.path+(<span class="keyword">char</span>)(i+<span class="number">48</span>);</span><br><span class="line">				<span class="keyword">if</span>(!s.h)&#123;<span class="built_in">print</span>(s);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">				q.<span class="built_in">push</span>(s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>P8106[Cnoi2021]数学练习-题解</title>
    <url>/2022/04/04/P8106-Cnoi2021-%E6%95%B0%E5%AD%A6%E7%BB%83%E4%B9%A0-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>这篇文章为洛谷P8106-Cnoi2021-数学练习的题解</p>
<span id="more"></span>
<h3 id="刚刚学完排列组合特来写一篇题解"><a href="#刚刚学完排列组合特来写一篇题解" class="headerlink" title="刚刚学完排列组合特来写一篇题解"></a>刚刚学完排列组合特来写一篇题解</h3><h2 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h2><p>首先题目要求我们将 $1$~$n$ 的数分为两个子集。<br>$|S| \notin S$ 且 $|T| \notin T$。<br>$|S|$ 表示的是 $S$ 集合中元素的个数。<br>由题目的特殊条件我们可以得到该条件的一个<strong>充要条件</strong> ：<br>$|S| \in T$ 且 $|T| \in S$。 </p>
<p>这样我们在 “ 安置 ”  好 $|S|$ 和 $|T|$ 后就可以用组合数公式轻松计算出答案了。<br>但是这边仍然有一个性质我们没有用到 ：<br><strong>当 $n$ 为偶数时</strong> $|S| \neq |T|$  这是显然的，也是<strong>必要</strong>的。  </p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><p>枚举 $1 $~$ n - 1 $ 作为 S 集合的元素个数。<br>已有  $ |T| \in S$。<br>利用组合数公式挑选剩下 $i - 1$ 个数。<br>由于 $n$ 个数全部挑完 ， 所以剩下的数全部纳入 $T$ 集合。<br>我们只需要算 $S$ 集合满足题意的个数即可。<br>附上组合数公式 ：<br><img src="https://s3.bmp.ovh/imgs/2022/03/235d693cdce2562d.webp"><br>注意到除号且在模意义下 ， 所以我们需要求 <strong>逆元</strong>。<br>注意到此题 $mod$ 的特殊性 ， 所以我们可以使用 <strong>费马小定理</strong> 求解逆元。<br>不知道逆元建议先做做 <a href="https://www.luogu.com.cn/problem/P3811">这道题</a>。<br>最后注意 <strong>特判 $n$ 为偶数</strong> 的情况就可以了。</p>
<h2 id="3-Code"><a href="#3-Code" class="headerlink" title="3. Code"></a>3. Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll mod=<span class="number">998244353</span>;</span><br><span class="line">ll n;</span><br><span class="line">ll frac[maxn];</span><br><span class="line">ll x,y;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll s,ll p)</span></span>&#123; <span class="comment">// 费马小定理求逆元</span></span><br><span class="line">	ll ans=<span class="number">1</span>; </span><br><span class="line">	<span class="keyword">while</span>(s)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s&amp;<span class="number">1</span>) ans=ans*a%p;</span><br><span class="line">		a=a*a%p;</span><br><span class="line">		s&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll m,ll n)</span></span>&#123;</span><br><span class="line">	ll x=<span class="built_in">inv</span>(frac[m]*frac[n-m]%mod,mod<span class="number">-2</span>,mod);</span><br><span class="line">    <span class="keyword">return</span> frac[n]*x%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    frac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) frac[i]=frac[i<span class="number">-1</span>]*i%mod; <span class="comment">// 预处理阶乘</span></span><br><span class="line">    ll mid=n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">bool</span> judge=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) judge=<span class="literal">true</span>;</span><br><span class="line">   	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">   		<span class="keyword">if</span>(judge==<span class="literal">true</span>&amp;&amp;i==mid) <span class="keyword">continue</span>; <span class="comment">// 特判 n 为偶数</span></span><br><span class="line">   		ans=(ans+<span class="built_in">C</span>(i<span class="number">-1</span>,n<span class="number">-2</span>))%mod;</span><br><span class="line">	&#125; </span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity游戏开发日志</title>
    <url>/2022/02/03/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="2022-2-2"><a href="#2022-2-2" class="headerlink" title="2022.2.2"></a>2022.2.2</h1><p>1.完成Unity在VS中的环境配置<br>2.完成C#Script的创建<br>3.实现tilemap障碍物刚体<br>4.实现角色碰撞体和物理配置<br>5.实现角色Idle和run动画机的创建<br>6.实现角色Idle和run时方向的变换<br>7.解决角色方向变换不协调的问题  </p>
<h1 id="2022-2-4"><a href="#2022-2-4" class="headerlink" title="2022.2.4"></a>2022.2.4</h1><p>1.完成Idle的Bool参数设定，Attack的Trigger参数设定<br>2.实现角色单次攻击  </p>
<h1 id="2022-2-6"><a href="#2022-2-6" class="headerlink" title="2022.2.6"></a>2022.2.6</h1><p>1.完成Attack的Int参数设定，Attack的Bool参数设定<br>2.引入连击计数器HitCount<br>3.实现人物多段攻击<br>4.实现攻击结束函数<br>5.实现攻击结束函数在攻击动画尾帧的插入  </p>
]]></content>
      <categories>
        <category>Unity游戏开发</category>
      </categories>
      <tags>
        <tag>Unity日志</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理</title>
    <url>/2022/02/04/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>这篇文章主要介绍<strong>中国剩余定理及其解法</strong>以及<strong>代码实现</strong></p>
<span id="more"></span>
<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><h2 id="引子：曹冲养猪"><a href="#引子：曹冲养猪" class="headerlink" title="引子：曹冲养猪"></a>引子：曹冲养猪</h2><p>题目链接：<a href="https://www.luogu.com.cn/problem/P1495">https://www.luogu.com.cn/problem/P1495</a><br>自从曹冲搞定了大象以后，曹操就开始捉摸让儿子干些事业，于是派他到中原养猪场养猪，可是曹冲满不高兴，于是在工作中马马虎虎，有一次曹操想知道母猪的数量，于是曹冲想狠狠耍曹操一把。举个例子，假如有 1616 头母猪，如果建了 33 个猪圈，剩下 11 头猪就没有地方安家了。如果建造了 55 个猪圈，但是仍然有 11 头猪没有地方去，然后如果建造了 77 个猪圈，还有 22 头没有地方去。你作为曹总的私人秘书理所当然要将准确的猪数报给曹总，你该怎么办？</p>
<p>类似此类问题我们可以使用<strong>中国剩余定理</strong>求解<br>限制条件<strong>模两两互质</strong></p>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>推导过程来源于<a href="https://baike.baidu.com/item/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86/2841597?fromtitle=%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86&fromid=11200132&fr=aladdin"><strong>百度百科</strong></a>(主要是<em>太菜了</em>不会推导)<br><img src="https://s3.bmp.ovh/imgs/2022/02/55836b4e60ab409a.png"><br><img src="https://s3.bmp.ovh/imgs/2022/02/fee95cb9985307ad.png"></p>
<h2 id="求解模板"><a href="#求解模板" class="headerlink" title="求解模板"></a>求解模板</h2><p>以如下问题为例<br>问：有数模3余2，模5余3，模7余2，问数几何？</p>
<ul>
<li><strong>衍数</strong>：lcm&#x2F;除数</li>
<li><strong>逆元</strong>：为衍数模除数意义下的数论倒数，设衍数为a,除数为b，则逆元为ax ≡ 1(mod b)的最小正整数解</li>
<li><strong>各总</strong>：余数 * 衍数 * 逆元</li>
</ul>
<table>
<thead>
<tr>
<th><strong>除数</strong></th>
<th><strong>余数</strong></th>
<th><strong>除数最小公倍数(lcm)</strong></th>
<th><strong>衍数</strong></th>
<th><strong>逆元</strong></th>
<th><strong>各总</strong></th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>2</td>
<td>105</td>
<td>35</td>
<td>2</td>
<td>140</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>105</td>
<td>21</td>
<td>1</td>
<td>63</td>
</tr>
<tr>
<td>7</td>
<td>2</td>
<td>105</td>
<td>15</td>
<td>1</td>
<td>30</td>
</tr>
</tbody></table>
<p>将”各总”相加得到特解233<br>最后将233对lcm取模得到最小正整数解23<br>23即为所求</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">		x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">	y-=(a/b)*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) m[i]=<span class="built_in">read</span>(),ai[i]=<span class="built_in">read</span>();</span><br><span class="line">	ll M=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) M*=(ll)m[i];<span class="comment">//求lcm </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) mi[i]=M/m[i];<span class="comment">//求衍数 </span></span><br><span class="line">	<span class="comment">//求逆元</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">exgcd</span>(mi[i],m[i],x,y);ti[i]=(x%m[i]+m[i])%m[i];<span class="built_in">init</span>();&#125;</span><br><span class="line">	ll minx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) minx+=(mi[i]*ai[i]*ti[i])%M;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,minx%M);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>同余&amp;逆元&amp;不定方程</title>
    <url>/2022/02/04/%E5%90%8C%E4%BD%99/</url>
    <content><![CDATA[<p>这篇文章主要介绍<strong>同余</strong>&amp;<strong>逆元</strong>&amp;<strong>不定方程</strong>及<strong>代码实现</strong></p>
<span id="more"></span>
<p>由于本人比较<em>菜</em>，所以一些定理不予证明</p>
<h1 id="同余的概念"><a href="#同余的概念" class="headerlink" title="同余的概念"></a>同余的概念</h1><p>同余定理是数论中的重要概念。给定一个正整数m，如果两个整数a和b满足（a-b）能够被m整除，即（a-b）&#x2F;m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)<br>【定义】设m是大于1的正整数，a、b是整数，如果m|(a-b)，则称a与b关于模m同余，记作a≡b(mod m)。显然易得如下：</p>
<p>1.若a≡0(mod m)，则m|a;<br>2.a≡b(mod m)等价于a与b分别用m去除，余数相同。<br><strong>充要性证明</strong><br>充分性：<br>若a和b用m相除留下相同的余数r，则 a&#x3D;q1m+r, b&#x3D;q2m+r,q1和q2为某两个整数，由此的a-b&#x3D;(q1m+r)-(q2m-r)&#x3D;m(q1-q2)，根据整除定义，我们有m|(a-b)，由同余式定义得出结论：a≡b(mod m)<br>必要性：<br>若a和b用m相除留下相同的余数r，则 a&#x3D;q1m+r,b&#x3D;q2m+r,所以a-b&#x3D;m(q1-q2) 故 m|(a-b)。<br><strong>同余性质</strong><br>反身性：a≡a (mod m)</p>
<p>对称性： 若a≡b(mod m)，则b≡a(mod m)</p>
<p>传递性： 若a≡b(mod m)，b≡c(mod m)，则a≡c(mod m)</p>
<p>同余式相加：若a≡b(mod m)，b≡c(mod m)，则a ± c≡b ± d(mod m)</p>
<p>同余式相乘：若a≡b(mod m)，b≡c(mod m)，则ac≡bd(mod m)</p>
<p>线性运算：如果a≡b(mod m)，c≡d(mod m)，那么a ± c≡b ± d(mod m)，且a * c≡b * d(mod m)</p>
<p>除法：若ac ≡ bc (mod m) c≠0 则 a≡ b (mod m&#x2F;gcd(c,m)) 其中gcd(c,m)表示c,m的最大公约数。特殊地 ,gcd(c,m)&#x3D;1 则a ≡ b (mod m)</p>
<p>幂运算：如果a ≡ b (mod m)，那么a^n ≡ b^n (mod m)</p>
<p>若a ≡ b (mod m)，n|m,则 a ≡ b (mod n)</p>
<p>若a ≡ b (mod mi) (i&#x3D;1,2…n) 则 a ≡ b (mod [m1,m2,…mn]) 其中[m1,m2,…mn]表示m1,m2,…mn的最小公倍数</p>
<h1 id="逆元-amp-不定方程"><a href="#逆元-amp-不定方程" class="headerlink" title="逆元&amp;不定方程"></a>逆元&amp;不定方程</h1><h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p>每个数a均有唯一的与之对应的乘法逆元x，使得ax≡1(mod b) ， 一个数有逆元的<strong>充分必要条件是gcd(a,b)&#x3D;1</strong>，此时逆元唯一存在 。<br>【含义】模b意义下，1个数a如果有逆元x，那么除以a相当于乘以x。<br>【定义】正整数 a, b，如果有 ax ≡ 1(mod b)，则称 x 的最小正整数解为 a 模 b的<strong>逆元</strong>  </p>
<h2 id="不定方程"><a href="#不定方程" class="headerlink" title="不定方程"></a>不定方程</h2><p>【定义】形如ax+by&#x3D;c（a，b，c均为常数，且a，b均不为0），一般情况下，每一个x的值都有一个y值和它相对应，有无穷多组解。如果方程（组）中，解的数值不能唯一确定，这样的方程（组）称为不定方程<br><strong>不定方程有整数解的条件</strong><br>整系数二元不定方程ax+by&#x3D;c中的系数a，b的最大公约数能整除c。<br>反之，如果<strong>if(c%gcd(a,b))</strong> 则 <strong>无解</strong></p>
<h2 id="逆元-amp-不定方程解法"><a href="#逆元-amp-不定方程解法" class="headerlink" title="逆元&amp;不定方程解法"></a>逆元&amp;不定方程解法</h2><h3 id="扩展欧几里得算法求不定方程"><a href="#扩展欧几里得算法求不定方程" class="headerlink" title="扩展欧几里得算法求不定方程"></a>扩展欧几里得算法求不定方程</h3><p>引：裴蜀定理<br>~ 设a, b是<strong>不全为零</strong>的整数，则存在整数x, y 使得 ax + by &#x3D; gcd(a, b)</p>
<p>我们都知道，欧几里得公式可以由这个式子表达<br><strong>gcd(a, b) &#x3D; gcd(b, a % b)</strong><br>通过这个式子，我们可以不断递推到b &#x3D; 0， 此时a即为a和b的<strong>最大公约数</strong><br>将式子展开得到如下<br><strong>1.gcd(a, b) &#x3D; a * x1 + b * x1</strong><br><strong>2.gcd(b, a % b) &#x3D; b * x2 + (a % b) * y2</strong><br>由欧几里得公式可得到<br><strong>a * x1+b * x1&#x3D;b * x2 + (a % b) * y2</strong><br>其中 <strong>a % b &#x3D; a - (a &#x2F; b) * b</strong><br>得 <strong>a * x1 + b * y1 &#x3D; b * x2 + [a - (a &#x2F; b) * b]y2</strong><br>化简得 <strong>a * x1 + b * y1 &#x3D; a * y2 + b * [x2 - (a &#x2F; b) * y2]</strong><br>由<strong>待定系数法</strong>得：<br><strong>1.x1 &#x3D; y2</strong><br><strong>2.y1 &#x3D; x2 - (a &#x2F; b) * y2</strong><br><em>以上即扩展欧几里得算法</em><br>也就是说有了<strong>gcd(b, a % b)的解x2, y2</strong>就可以推出<strong>gcd(a, b)的解x1, y1</strong><br>我们可以用类似求gcd的方法求解，一直推到x&#x3D;1,y&#x3D;0(递归边界)，然后回溯即可求出特解</p>
<h3 id="通过特解求出最小整数解-amp-通解"><a href="#通过特解求出最小整数解-amp-通解" class="headerlink" title="通过特解求出最小整数解&amp;通解"></a>通过特解求出最小整数解&amp;通解</h3><p>设特解分别为x0,y0<br>则最小解为：<br><strong>x0&#x3D;x0%(b&#x2F;gcd(a,b))</strong><br>则通解为：<br><strong>x&#x3D;x0+k*b&#x2F;gcd(a,b)</strong><br><strong>y&#x3D;y0-k*a&#x2F;gcd(a,b)</strong><br>又因为方程建立在gcd基础上，方程左边为gcd而非c，所以答案需在上面的基础上乘上<br><strong>c&#x2F;gcd(a,b)</strong><br>所以最小解为<br><strong>x0&#x3D;(x0*c&#x2F;gcd(a,b))%(b&#x2F;gcd)</strong>  </p>
<p>易知<strong>逆元为特殊的不定方程</strong>，ax≡1(mod b) 等价于ax-by&#x3D;1<br>所以同样可以用<strong>扩展欧几里得算法求解</strong>  </p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>扩展欧几里得算法的三大应用  </p>
<h2 id="求不定方程ax-by-x3D-c的最小正整数解"><a href="#求不定方程ax-by-x3D-c的最小正整数解" class="headerlink" title="求不定方程ax+by&#x3D;c的最小正整数解"></a>求不定方程ax+by&#x3D;c的最小正整数解</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">		x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">	y-=(a/b)*x;</span><br><span class="line">&#125;<span class="comment">//x即为特解;</span></span><br><span class="line"><span class="keyword">int</span> mod=b/(<span class="built_in">gcd</span>(a,b));</span><br><span class="line">ans=(x*(c/<span class="built_in">gcd</span>(a,b))%mod+mod)%mod;</span><br><span class="line"><span class="comment">//小技巧，+mod后%mod可以防止出现负解;</span></span><br></pre></td></tr></table></figure>
<h2 id="求方程ax≡1-mod-b-的最小正整数解-a的逆元"><a href="#求方程ax≡1-mod-b-的最小正整数解-a的逆元" class="headerlink" title="求方程ax≡1(mod b) 的最小正整数解(a的逆元)"></a>求方程ax≡1(mod b) 的最小正整数解(a的逆元)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">		x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">	y-=(a/b)*x;</span><br><span class="line">&#125;<span class="comment">//x即为特解;</span></span><br><span class="line"><span class="comment">//已知gcd(a,b)=1,则mod=b/gcd(a,b)=b;</span></span><br><span class="line"><span class="comment">//同理，c/gcd(a,b)=1/1=1;</span></span><br><span class="line">ans=(x%b+b)%b<span class="comment">//求出最小整数解&amp;防止出现负解;</span></span><br></pre></td></tr></table></figure>

<h2 id="求模线性方程ax≡b-mod-n"><a href="#求模线性方程ax≡b-mod-n" class="headerlink" title="求模线性方程ax≡b (mod n)"></a>求模线性方程ax≡b (mod n)</h2><p>对于模线性方程ax≡b (mod n)可以化简为ax+ny&#x3D;b设d&#x3D;gcd(a,n)<br>则当且仅当b%d&#x3D;&#x3D;0时方程有解，且有d个解<br>等式两边同时乘以b&#x2F;d，则方程变为axb&#x2F;d+nyb&#x2F;d&#x3D;b<br>设ax+ny&#x3D;d特解为x‘,y’<br>则原方程解为x&#x3D;x‘ * b&#x2F;d，y&#x3D;y’ * b&#x2F;d<br>故ax≡b (mod n)特解为<strong>x0&#x3D;x’ * (b&#x2F;d)%n</strong><br>d个解为xi&#x3D;x0+i*(n&#x2F;d)%n (i&#x3D;0,1,…,n-1)<br>解的间隔为<strong>n&#x2F;d</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;gcd,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">		x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">		gcd=a;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">	y-=(a/b)*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_find</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,x0,gcd;</span><br><span class="line">	<span class="built_in">exgcd</span>(a,b,gcd,x,y);</span><br><span class="line">	<span class="keyword">int</span> d=gcd;</span><br><span class="line">	<span class="keyword">if</span>(b%d) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	x0=x*(b/d)%n;<span class="comment">//特解</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,i&lt;d;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x0+i*(n/d));</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟退火</title>
    <url>/2022/03/05/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/</url>
    <content><![CDATA[<p>这篇文章主要介绍<strong>模拟退火算法</strong>的原理以及实现</p>
<span id="more"></span>
<h1 id="算法来源"><a href="#算法来源" class="headerlink" title="算法来源"></a>算法来源</h1><p>在物理学中，当一个物体的温度很高的时候，这个物体会由高温状态转变为低温状态，而其内部的粒子也 <strong>逐渐</strong> 由无序转变为有序。这就给我们提供了设计算法的思路：模拟粒子的无序状态，即 <strong>随机化</strong> ，而当”温度“越来越低的时候，粒子越来越有序，而我们随机化的 <strong>幅度</strong> 越来越小，最后就可以得到我们想要的最优解</p>
<h2 id="典例"><a href="#典例" class="headerlink" title="典例"></a>典例</h2><p>这里选取来自<a href="https://oi-wiki.org/misc/simulated-annealing/">oi-wiki</a>的一张图片来具象说明<br><img src="https://s3.bmp.ovh/imgs/2022/03/95370912b602b0d5.gif"></p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>由算法原理我们可以提取几个关键词：<strong>逐渐</strong>、<strong>随机化</strong>、<strong>幅度</strong><br>由此我们可以得到算法实现的基本思路：<br>定义出一个 <strong>足够高的温度T</strong>  （T一定要<strong>足够高！！！</strong>）<br>随机化答案，找到更优解替换当前解<br>那么我们会不会因为如此而陷入”目光短浅”的僵局呢？<br>答案是肯定会的！<br>例如拥有多个峰值的函数，如果单单朝着较优解进发，就很有可能会 <strong>错失最优解</strong><br>所以当我们需要以 <strong>一定概率接受较差解</strong> ，用于跳出这种“僵局”<br>那么这个概率是多少呢？<br>科学家们以及帮我们计算好了:<br>$e^{-\Delta&#x2F;T}$  </p>
<ul>
<li>$\Delta$ 为当前解和已知解的 <strong>差值的绝对值</strong> </li>
<li>$T$ 为当前温度</li>
</ul>
<p>易知 $e^{-\Delta&#x2F;T} \in [0 , 1] $ 且随着 $ T $ 的增大而减小<br>即随机化的程度越来越小</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>选自洛谷<a href="https://www.luogu.com.cn/problem/P1337">P1337 [JSOI2004]平衡点 &#x2F; 吊打XXX</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10006</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> ansx=<span class="number">0</span>,ansy=<span class="number">0</span>,dis=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">double</span> x[maxn],y[maxn],m[maxn];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">double</span> x1,<span class="keyword">double</span> y1,<span class="keyword">double</span> x2,<span class="keyword">double</span> y2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">double</span>)<span class="built_in">sqrt</span>((<span class="keyword">double</span>)<span class="number">1.0</span>*(x1-x2)*(x1-x2)+(<span class="keyword">double</span>)<span class="number">1.0</span>*(y1-y2)*(y1-y2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算带权费马点</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">census</span><span class="params">(<span class="keyword">double</span> x1,<span class="keyword">double</span> y1)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res+=(<span class="keyword">double</span>)<span class="built_in">dist</span>(x[i],y[i],x1,y1)*m[i];</span><br><span class="line">	<span class="keyword">if</span>(res&lt;dis) dis=res,ansx=x1,ansy=y1;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Rand</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">double</span>)<span class="built_in">rand</span>()/RAND_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sian</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> t=<span class="number">10000000</span>;<span class="comment">//足够高的温度</span></span><br><span class="line">	<span class="keyword">while</span>(t&gt;<span class="number">1e-15</span>)&#123;</span><br><span class="line">		<span class="keyword">double</span> x1=ansx+t*(<span class="number">2</span>*<span class="built_in">rand</span>()-RAND_MAX);</span><br><span class="line">		<span class="keyword">double</span> y1=ansy+t*(<span class="number">2</span>*<span class="built_in">rand</span>()-RAND_MAX);</span><br><span class="line">		<span class="keyword">double</span> delt=<span class="built_in">census</span>(ansx,ansy)-<span class="built_in">census</span>(x1,y1);</span><br><span class="line">        <span class="comment">//如果得到较优解就替换或概率接受较差解</span></span><br><span class="line">		<span class="keyword">if</span>(delt&gt;<span class="number">0</span>||<span class="built_in">exp</span>(delt/t)*RAND_MAX&gt;<span class="built_in">rand</span>()) ansx=x1,ansy=y1;</span><br><span class="line">		t*=<span class="number">0.997</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">double</span> x1=ansx+t*(<span class="number">2</span>*<span class="built_in">Rand</span>()<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">double</span> y1=ansy+t*(<span class="number">2</span>*<span class="built_in">Rand</span>()<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">census</span>(x1,y1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于是随机化，比较看脸，多刷几次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runn</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">sian</span>();</span><br><span class="line">	<span class="built_in">sian</span>();</span><br><span class="line">	<span class="built_in">sian</span>();</span><br><span class="line">	<span class="built_in">sian</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">0</span>,cf=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)cf=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*cf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>,&amp;x[i],&amp;y[i],&amp;m[i]);</span><br><span class="line">		ansx+=x[i],ansy+=y[i];</span><br><span class="line">	&#125;</span><br><span class="line">	ansx=<span class="number">1.0</span>*ansx/n,ansy=<span class="number">1.0</span>*ansy/n;</span><br><span class="line">	<span class="built_in">runn</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.3lf %.3lf&quot;</span>,ansx,ansy);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟退火</tag>
      </tags>
  </entry>
</search>
